<!DOCTYPE  html>
<html>
<head>
	<meta charset="utf-8">
	<meta charset="viewport" content="width=device-width, initial-scale=1">
	<title>Мертвые языки программирования</title>
	<link rel="stylesheet" href="style.css" media="all">
</head>
<body>
<header id="8" class="header">
  <div class="container">
      <div class="header_inner">
        <div class="logo">Мертвые языки</div>
        <nav class="nav">
          <a class="nav_link" href="index.html">Главная</a>
          <a class="nav_link" href="index1.html">История</a>
          <a class="nav_link" href="index2.html">Эволюция</a>
          <a class="nav_link" href="index3.html">Мертвые языки</a>
          <a class="nav_link" href="index4.html">Причины</a>
        </nav>
      </div>
  </div>
</header>
  
<p id='aboba'></p>


<section id="3" class="section">
	<div class="container"></div>
		<div class="section_header">
			<h2 class='section_title'>Эволюция языков программирования. Классификация языков программирования</h2>
			<div class="table">
				<div class="about_item">
					<img  src="images/table1.png"   alt="">
				</div>
			</div>
			<div class="section_text">
				<p>Развитие вычислительной техники сопровождается созданием новых и совершенствованием существующих
					 средств общения программистов с ЭВМ - языков программирования (ЯП). Проанализируем таблицу и
					  установим зависимость развития ЯП от развития ЭВМ. ЯП первого поколения представляли собой 
						набор машинных команд в двоичном (бинарном) или восьмеричном формате, который определялся
						 архитектурой конкретной ЭВМ. Каждый тип ЭВМ имел свой ЯП, программы на котором были пригодны 
						 только для данного типа ЭВМ. От программиста при этом требовалось хорошее знание не только
						  машинного языка, но и архитектуры ЭВМ. Второе поколение ЯП характеризуется созданием языков
							 ассемблерного типа, позволяющих вместо двоичных и других форматов машинных команд использовать
							  их мнемонические символьные обозначения. Являясь существенным шагом вперед, ассемблерные языки 
								все еще оставались машинно-зависимыми, а программист все также должен был быть хорошо знаком с 
								организацией и функционированием аппаратной среды конкретного типа ЭВМ. При этом ассемблерные
								 программы все так же затруднительны для чтения, трудоемки при отладке и требуют больших усилий 
								 для переноса на другие типы ЭВМ. Однако и сейчас ассемблерные языки используются при необходимости разработки высокоэффективного программного обеспечения. Третье поколение ЯП начинается с появления в 1956 г. первого языка высокого уровня - Fortran, разработанного под руководством Дж. Бэкуса в фирме IBM. За короткое время Fortran становится основным ЯП при решении инженерно-технических и научных задач. Постоянное развитие языка сделало его одним из самых распространенных ЯВУ на ЭВМ всех классов - от микро- до супер-ЭВМ, а его версии используются и для вычислительных средств нетрадиционной параллельной архитектуры. Вскоре после языка Fortran появились такие ныне широко известные языки, как Algol, Cobol и др. В настоящее время насчитывается свыше 2000 различных языков высокого уровня. Языки четвертого поколения носят ярко выраженный непроцедурный характер, определяемый тем, что программы на таких языках описывают только что, а не как надо сделать. В программах формируются скорее соотношения, а не последовательности шагов выполнения алгоритмов. Типичными примерами непроцедурных языков являются языки, используемые для задач искусственного интеллекта. Языки программирования от поколения к поколению улучшали свои характеристики, становясь все более доступными в освоении непрофессионалам. Все языки программирования делятся на два уровня: низкий и высокий.
					Бэйсик использует обозначения подобные обычным математическим выражениям. Поэтому этот язык позволяет решать достаточно широкий круг задач. Позволим выделить некоторую общую тенденцию в развитии языков программирования. Языки развиваются в сторону все большей и большей абстракции. И это сопровождается падением эффективности. Вопрос: а стоит ли этого абстракция? Ответ: стоит. Стоит, так как повышение уровня абстракции влечет за собой повышение уровня надежности программирования. С низкой эффективностью можно бороться путем создания более быстрых компьютеров. Если требования к памяти слишком высоки, можно увеличить ее объем. Это, конечно, требует времени и средств, но это решаемо. А вот с ошибками в программах можно бороться только одним способом: их надо исправлять. А еще лучше — не совершать. А еще лучше максимально затруднить их совершение. И именно на это направлены все исследования в области языков программирования. А с потерей эффективности придется смириться.
					</p>
			</div>

</section>

<p><a class="link"  href="#aboba"><img src="images/aboba.png" width="60" height="60" alt=""></a></p>


</body>
</html>